objects:
	space ship
	stars, planets, moons, asteroids, ... (over 1 million units)


main loop:
	update physics
		update dynamic objects
			- high freq if visible, low freq if not
		update orbital objects
			- high freq if visible, low freq if not

	update AI ???

	update visibility
		components:
			- bounding sphere
			- min, max LOD, bias
			- ref to render objects

		hierarchy:
			d=0 components
			d=1 components
			...
			
		for each viewport (primary cameras)
			test intersection with secondary cameras (shadow/reflection/...)
		for each reflection camera
			test intersection with secondary cameras
		build camera graph

		for each camera
			for each hierarchy level
				for each bounding sphere in hierarchy level
					test visibility
					if not visible
						add message: remove childs
						if depth != 0
							remove self ???
					if visible
						calculate LOD
						add message: add child bounding spheres (depends on LOD)
						add message: update render objects (if LOD changed)
				process messages
					remove bounding spheres in level+1
					add bounding spheres to level+1
					update render objects
						delete current render objects
						read render objects for current LOD from DB (render component?)
						insert new render objects to render passes for current camera

	render
		components:
			- ref to visibility object
			- ref to render cache object
			- pipeline (material + render pass)
			- {push constants}

		render cache components:
			- draw call
			- mesh (VB / VB+IB / SSBO for mesh shader / TLAS for ray tracing)
			- material descriptor set
			- object descriptor set (single or double buffering)
			- unifrom buffer for object descriptor set (MVP matrix, etc)

		sort cameras
		for each camera
			update object UB and PC for each component (matrices)
			build pipelines (if not in cache)
			create descriptor sets (if not in cache)
			update meshes (upload VB, IB ...)
			
			for each render pass
				sort draw calls
			if render pass was changed
				reuild secondary command buffer
			add render pass and secondary command buffer to primary command buffer
			submit (optional)
